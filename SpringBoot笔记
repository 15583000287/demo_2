Spring和SpringBoot的区别：
    虽然Spring组件的代码是轻量级的，但它的配置是重量级的。

SpringBoot的注解：
@SpringBootApplication   SpringBoot核心注解，开启自动配置，表示当前类是SpringBoot的的引导类
    包含以下注解：
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @Documented   //表示生成文档的时候，包含注解注释
    @Inherited //表示被此注解注解的类，继承它父类的注解
    -----以上是四个元注解-------
    @SpringBootConfiguration  //表示当前类是一个配置类
        包含：元注解
              @Configuration  //配置类注解(表示被注解的类是一个配置类)
    @EnableAutoConfiguration //表示启用自动配置
    //注解扫描(扫描范围为Application.java启动类所在包及其子包)
    @ComponentScan(excludeFilters = {
            @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
            @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })

    注：SpringBoot并不是不需要写配置或注解了，它只是将其进行了封装，使我们使用起来更方便。





SpringBoot注意事项：
    数据源使用application.yml文件配置(注意url后面是否正确)
    格式：
    spring:
      datasource:
        url: jdbc:mysql://localhost:3306/spring_boot?useUnicode=true&characterEncoding=utf8&serverTimezone=GMT
        username: root
        password: 123

单元测试：
    https://blog.csdn.net/sz85850597/article/details/80427408
    @RunWith(SpringRunner.class)
    @SpringBootTest
    public class LearnServiceTest {

        @Autowired
        private UserService userService;

        @Test
        public void getLearn(){
            //测试
        }
    }


过滤器配置：
    1.新建一个XxxFilter 实现（implements）javax.servlet.Filter接口,并重写其中的方法
    2.通过注解方式配置过滤器
         在过滤器上添加WebFilter注解  @WebFilter(filterName = "sessionFilter",urlPatterns = {"/*"})
         在启动类添加ServletComponentScan注解
    2.通过过滤器注册配置类使用过滤器(将过滤器加入过滤器链)
         @Configuration
         public class WebComponent2Config {
             @Bean
             public FilterRegistrationBean someFilterRegistration1() {
                 //新建过滤器注册类
                 FilterRegistrationBean registration = new FilterRegistrationBean();
                 // 添加我们写好的过滤器
                 registration.setFilter( new SessionFilter());
                 // 设置过滤器的URL模式
                 registration.addUrlPatterns("/*");
                 return registration;
             }

         }
     3.设置过滤器执行顺序
         a.配置无法设置顺序，但是可以通过过滤器名字的字典顺序实现顺序过滤（比如AFilter就会在BFilter前执行），显然这种方法看起来不怎么正经。
         b.通过给注册类设置order，设置过滤器顺序(值越小执行优先级越高)
         registration.setOrder(1);



自定义property
    1.配置在application.properties中
        com.neo.title=纯洁的微笑
        com.neo.description=分享生活和技术
    2.自定义配置类
         @Component
         public class NeoProperties {
            @Value("${com.neo.title}")
            private String title;
            @Value("${com.neo.description}")
            private String description;

            //省略getter settet方法
         }


       index:https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483679&idx=1&sn=ce9ac5cdceac9e3abc1c10545401f2d4&chksm=ebf6d960dc81507667f3c1fc2c6ed445050a37309ff690b34e091d836a15e86d64a33f61d4f0&scene=21#wechat_redirect



log配置：
    日志级别总共有TARCE < DEBUG < INFO < WARN < ERROR < FATAL
    1.配置输出的地址(绝对路径)
        logging.path=C:/Users/Administrator/Downloads/SpringBootJPATest2018.12.22-master
    1.配置文件名（使用相对路径）
        logging.file=log/springbootlog

    2.配置输出级别（不同包下的日志可配置不同的级别）
        logging.level.com.favorites=DEBUG
        logging.level.org.springframework.web=INFO
        logging.level.org.hibernate=ERROR

    3.配置日志格式(控制台和文件中)
      logging.pattern.console=%d{yyyy/MM/dd-HH:mm:ss} [%thread] %-5level %logger- %msg%n
      logging.pattern.file=%d{yyyy/MM/dd-HH:mm} [%thread] %-5level %logger- %msg%n

        %d{HH:mm:ss.SSS}——日志输出时间

        %thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用

        %-5level——日志级别，并且使用5个字符靠左对齐

        %logger- ——日志输出者的名字

        %msg——日志消息

        %n——平台的换行符




异常处理：
    1.自定义异常类，继承RuntimeException（spring事务在运行时抛出异常将会回滚）
    2.定义异常处理类
    @RestControllerAdvice
    public class MobaoExceptionHandler {

        @ExceptionHandler(RuntimeException.class)

        public Result<Void> MobaoException(){
            return new Result<Void>(0,"运行异常！");
        }
    }





数据库操作之SpringDataJpa：(MySQL + Spring Data JPA)
    1.添加jar包
         <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-jpa</artifactId>
            </dependency>
             <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
            </dependency>

    2.添加配置文件
        1.数据源配置
        spring.datasource.url=jdbc:mysql://localhost:3306/test
        spring.datasource.username=root
        spring.datasource.password=root
        spring.datasource.driver-class-name=com.mysql.jdbc.Driver

        2.其他配置(博客：https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483679&idx=1&sn=ce9ac5cdceac9e3abc1c10545401f2d4&chksm=ebf6d960dc81507667f3c1fc2c6ed445050a37309ff690b34e091d836a15e86d64a33f61d4f0&scene=21#wechat_redirect)
        spring.jpa.properties.hibernate.hbm2ddl.auto=update    (四个取值create  create-drop  update  validata)   update最常用
        spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect   主要是指定生成表名的存储引擎为InneoDB
        spring.jpa.show-sql= true 是否打印出自动生产的SQL，方便调试的时候查看

    3.自定XxxRepository类继承JpaRepositoty<实体类型, ID类型>
        Spring Data JPA 根据自动方法名生成sql语句


数据库操作之MyBatis：(MySQL + MyBatis)
    1.添加spring boot 的 mybatis jar包依赖
         <dependency>
                    <groupId>org.mybatis.spring.boot</groupId>
                    <artifactId>mybatis-spring-boot-starter</artifactId>
                    <version>1.3.2</version>
         </dependency>
    2.配置数据源(同上)
    3.启动类配置@MapperScan(basePackages = "cn.tedu.demo_1.repository") //或者在每个持久层接口添加@Mapper也可以，但是很麻烦。
    4.使用注解配置映射关系，接口方法上使用对应注解写sql语句（@Select @Update ...）  //或者是使用传统xml映射文件，可以灵活的动态生成sql,方便调整SQL语句
                                                              // 注解适合简单快速模式，尤其是为微服务模式，一个服务就对应一个自己的数据库，多表查询需求会大大降低。
       eg： @Select("SELECT * FROM users WHERE id = #{id}")
              @Results({
                  @Result(property = "userSex",  column = "user_sex", javaType = UserSexEnum.class),
                  @Result(property = "nickName", column = "nick_name")
              })
              UserEntity getOne(Long id);

    4.使用传统xml映射配置文件
           a.在application.properties文件中指定mybatis基础配置文件和实体类映射文件地址
                mybatis.config-locations=classpath:mybatis/mybatis-config.xml  配置类的别名，不用写完全限定名了
                mybatis.mapper-locations=classpath:mybatis/mapper/*.xml
           b.添加mybatis-config.xml与*.xml配置文件即可，详细见代码。

     注意：#{} 等价于 sql模板中的？     select * from user id = ?;
           ${} 直接做拼接操作，设计表字段值用这是,有sql注入风险





Thymeleaf模板
    //TODO

Gradle 构建工具
    //TODO


什么是WebJars
    什么是WebJars？WebJars是将客户端（浏览器）资源（JavaScript，Css等）打成jar包文件，以对资源进行统一依赖管理。WebJars的jar包部署在Maven中央仓库上。
    如何使用
    1、 WebJars主官网 查找对于的组件，比如Vuejs
    <dependency>
        <groupId>org.webjars.bower</groupId>
        <artifactId>vue</artifactId>
        <version>1.0.21</version>
    </dependency>
    2、页面引入
    <link th:href="@{/webjars/bootstrap/3.3.6/dist/css/bootstrap.css}" rel="stylesheet"></link>
    就可以正常使用了！








